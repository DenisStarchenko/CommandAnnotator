package ru.bmstu.iu3.annotator;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

import org.apache.uima.analysis_component.CasAnnotator_ImplBase;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.cas.CAS;
import org.apache.uima.cas.Feature;
import org.apache.uima.cas.Type;
import org.apache.uima.cas.text.AnnotationFS;
import org.apache.uima.jcas.JCas;

public class CommandAnnotator extends CasAnnotator_ImplBase {

	@Override
	public void process(CAS aCas) throws AnalysisEngineProcessException {
		try {
			readCommand();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return;
		}
		
		CAS originalView, commandView;

	    // get the CAS view for the original document
	    originalView = aCas.getView("OriginalDocument");

	    // Create the Command text Sofa and open its view
	    //commandView = aCas.createView("CommandDocument");

	    // Get some necessary Type System constants
	    Type annot = originalView.getAnnotationType();
	    Type cross = originalView.getTypeSystem().getType("ru.bmstu.iu3.CommandRecognizer");
	    Feature other = cross.getFeatureByBaseName("otherAnnotation");

	    // Get the English text
	    String orgText = originalView.getDocumentText();

	    // Setup for translated text
	    int orgEnd = 0;
	    int commandBegin = 0;
	    int commandEnd = 0;
	    StringBuffer translation = new StringBuffer();

	    // Parse the English text
	    StringTokenizer st = new StringTokenizer(orgText);
	    while (st.hasMoreTokens()) {
	      String thisTok = st.nextToken();
	      int orgBegin = orgText.indexOf(thisTok, orgEnd);
	      orgEnd = orgBegin + thisTok.length();

	      // Create token annotations on original  text
	      AnnotationFS orgAnnot = originalView.createAnnotation(annot, orgBegin, orgEnd);
	      originalView.addFsToIndexes(orgAnnot);

	      System.out.println("original BEGIN:"+orgBegin+" original END:"+orgEnd);
	      // Simple word-by-word translation
	      String commandWord = translate(thisTok);

	      // Accumulate the translated text
	      if (commandBegin > 0) {
	        translation.append(' ');
	        commandBegin += 1;
	      }
	      translation.append(commandWord);

	      // Create token annotations on command text
	      commandEnd = commandBegin + commandWord.length();
	      //AnnotationFS germAnnot = commandView.createAnnotation(cross, commandBegin, commandEnd);
	      //commandView.addFsToIndexes(germAnnot);
	      
	      // add link to original text
	      //germAnnot.setFeatureValue(other, orgAnnot);
	      commandBegin = commandEnd;
	   
	    }

	    // Finally, set the output tranlation Sofa data
	    //commandView.setDocumentText(translation.toString());


		System.out.print("\n\n\nCOMMANDS\n");
		System.out.print(Arrays.toString(commands.toArray()));
		System.out.print("\n\n\n\n");
	    
	  }

	  static ArrayList<String> commands;
	  
	  private void readCommand() throws FileNotFoundException, IOException {
		  Scanner s = new Scanner(new File("./commands/commands.txt"));
		  commands = new ArrayList<String>();
		  while (s.hasNext()){
		      commands.add(s.next());
		  }
		  s.close();
	  }
	  
	  private String translate(String word) {
		  for (String command:commands) {
			if(word.equals(command))
				return command;
		  }
		  return "Sorry, dont know such command :(";
      }

	}
